<p>It is always interesting to measure your skills in problem solving. One of the ways to check how good you are, is to participate in Facebook Hackercup. If you consider participating next year - I’d like to share my top 5 learnings from this year.</p>

<h3 id="1-train-yourself-to-understand-challenge-quickly">1. Train yourself to understand challenge quickly</h3>
<p>Challenges’ descriptions are huge. You have to be very attentive to get it right. After the problem is understood, it needs to be translated into a technical problem. You can train this skill using the <a href="https://www.facebook.com/hackercup/past_rounds/1825579961046099/">challanges from previous years</a>.</p>

<h3 id="2-solve-without-coding-first">2. Solve without coding first</h3>
<p>Every challenge has a sample input and output. Use this information. Although it is tempting to start coding right away, try to solve it step by step on paper or on a whiteboard. Make sure that you have the same output.</p>

<p>This approach will help you to see patterns or even to find a simple solution. For example, here is one of the challenges:</p>

<blockquote>
  <p>Consider an N-degree polynomial, expressed as follows:</p>

\[P_N * x^N + P_N-1 * x^N-1 + ... + P_1 * x^1 + P_0 * x^0\]

  <p>You’d like to find all of the polynomial’s $x$ ( 
all distinct real values of $x$ for which the expression evaluates to $0$).</p>

  <p>The order of operations has been reversed: Addition ($+$) now has 
the highest precedence, followed by multiplication ($*$), followed by exponentiation (^).</p>

  <p>Constraints: $P_N ≠ 0$</p>
</blockquote>

<p>After reading this you might think that this problem is somehow similar to <a href="https://en.wikipedia.org/wiki/3SUM">3-sum problem</a>. However if you put it down on paper or whiteboard it will be obvious that the solution is quite simple:</p>
<ul>
  <li>The polynomial can be evaluated to $0$ when $x = 0$ and polynomial’s degree is odd.</li>
  <li>Otherwise it cannot be evaluated to $0$.</li>
</ul>

<p>The code in the end will be simple:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">calculatePolynomialInterceptions</span><span class="p">(</span><span class="n">degree</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">degree</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="c1"># the only possible solution
</span>    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span> <span class="c1"># no such x
</span></code></pre></div></div>

<details><summary>Explanation</summary>
<p>

It might take some time to realise how a polynomial would look like after applying new operations order. Let's start with $N=3$ and write the polynomial down:


$P_3 * x$ ^ $3 + P_2 * x$ ^ $2 + P_1 * x$ ^ $1 + P_0 * x$ ^ 0

According to the order of operations it should look as following:

$(P_3 * x)$ ^ $((3 + P_2) * x)$ ^ $((2 + P_1) * x)$ ^ $((1 + P_0) * x)$ ^ $0$

From that we can see that we have $(P_3 * x)$ as a base and the rest as an exponent. We will refer to the exponent as $a$:

$a = ((3 + P_2) * x)$ ^ $((2 + P_1) * x)$ ^ $((1 + P_0) * x)$ ^ $0$

and will get the expression:

$$P_3 * x ^ a = 0$$ 

Since $P_3 ≠ 0$ according to the problem description, the polynomial can be evaluated to $0$ only and only when $x = 0$ and $a ≠ 0$. 

We have found the $x$ and the only thing we need to do is to make sure that $a ≠ 0$, otherwise $P_3 * 0^0 = P_3$. 

Let's take a look at $a$. Since $x = 0$, we will get:

$a = ((3 + P_2) * 0)$ ^ $((2 + P_1) * 0)$ ^ $((1 + P_0) * 0)$ ^ $0$

$a = 0$ ^ $0$ ^ $0$ ^ $0$

$a = 1$

The answer is that the *3rd-degree* polynomial does evaluate to $0$ only and only when $x = 0$. However if it would be *2nd-degree* polynomial, it does not evaluate to $0$ for any real value $x$:

$a = 0$ ^ $0$ ^ $0$

$a = 0$

$P_2 * x^0 = P_2 * 1 = P_2 (≠ 0)$

It turns out that the final solution of this problem is quite easy - we just need to check whether the polynomial degree is odd, and if it is so then it can be evaluated to $0$ when $x = 0$.

</p>
</details>

<h3 id="3-use-brute-force-and-improve">3. Use brute force and improve</h3>
<p>Use a naive approach and solve a problem as quick as possible. Once you have a solution ask yourself following questions and try to improve these aspects if an answer is positive:</p>
<ul>
  <li>Are there bottlenecks?</li>
  <li>Are there duplicated work?</li>
  <li>Are there useless work?</li>
</ul>

<h3 id="4-solve-and-reverse-engineer-your-thought-process">4. Solve and reverse engineer your thought process</h3>
<p>Forget about your CS skills and try to solve a problem as a human or as a small kid. Got a solution? Reverse engineer your thought process and convert it into an algorithm.</p>

<p>For example you are challenged:</p>
<blockquote>
  <p>Given <a href="https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR)">Pre-order</a> and <a href="https://en.wikipedia.org/wiki/Tree_traversal#In-order_(LNR)">In-order</a> traversals of a tree, reconstruct the tree.</p>

  <p>In-order: A, B, C, D, E, F, I, G, H</p>

  <p>Pre-order: F, B, A, D, C, E, G, I, H</p>
</blockquote>

<p>What you can try is to reconstruct the tree without thinking about algorithms, loops, recursions, stacks whatsoever.</p>

<p>What we know is that in pre-order the left element is the root. Let’s draw the root:</p>

<pre><code class="language-mermaid">graph TD;
    F((F))
</code></pre>

<p>Next root element is <code class="language-plaintext highlighter-rouge">B</code> but where to put it - we don’t know yet. Looking at the in-order traversal result, we can notice that <code class="language-plaintext highlighter-rouge">F</code> splits it into two: <code class="language-plaintext highlighter-rouge">A, B, C, D, E</code> and <code class="language-plaintext highlighter-rouge">I, G, H</code>.</p>

<p>These are nodes that are on the left and on the right from our root <code class="language-plaintext highlighter-rouge">F</code>. Which nodes are children of <code class="language-plaintext highlighter-rouge">F</code>? The ones that come first in the pre-order - <code class="language-plaintext highlighter-rouge">B</code> and <code class="language-plaintext highlighter-rouge">G</code>:</p>

<pre><code class="language-mermaid">graph TD;
    F((F))--&gt;B((B));
    F--&gt;G((G));
</code></pre>

<p>Now <code class="language-plaintext highlighter-rouge">B</code> splits the in-order <code class="language-plaintext highlighter-rouge">A, B, C, D, E</code> into the only left child <code class="language-plaintext highlighter-rouge">A</code> and descendant ondes on the right <code class="language-plaintext highlighter-rouge">C, D, E</code>. Which node is the right child of <code class="language-plaintext highlighter-rouge">B</code>? The answer is <code class="language-plaintext highlighter-rouge">D</code>, since it comes first in the pre-order.</p>

<pre><code class="language-mermaid">graph TD;
    F((F))--&gt;B((B));
    F--&gt;G((G));
    B--&gt;A((A));
    B--&gt;D((D));
</code></pre>
<p>After repeating this process you will reconstruct the whole tree:</p>

<pre><code class="language-mermaid">graph TD;
    F((F))--&gt;B((B));
    F--&gt;G((G));
    B--&gt;A((A));
    B--&gt;D((D));
    D--&gt;C((C));
    D--&gt;E((E));
    G--&gt;I((I));
    G--&gt;H((H));
</code></pre>

<p>What you can do now is to wrap this process into an algorithm:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">reconstructTree</span><span class="p">(</span><span class="n">in_order</span><span class="p">,</span> <span class="n">pre_order</span><span class="p">):</span>
    <span class="c1"># if pre_order is empty - return None
</span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pre_order</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="c1"># extract first from pre_order as root
</span>    <span class="n">root</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">pre_order</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">pre_order</span> <span class="o">=</span> <span class="n">pre_order</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="c1"># split in_order based on the root into:
</span>    <span class="n">in_order_left</span> <span class="o">=</span> <span class="n">in_order</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">in_order</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">root</span><span class="p">)]</span>
    <span class="n">in_order_right</span> <span class="o">=</span> <span class="n">in_order</span><span class="p">[</span><span class="n">in_order</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">root</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
    
    <span class="c1"># split pre_order based on in_order_right &amp;in_order_left into:
</span>    <span class="n">pre_order_left</span> <span class="o">=</span> <span class="n">pre_order</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">in_order_left</span><span class="p">)]</span>
    <span class="n">pre_order_right</span> <span class="o">=</span> <span class="n">pre_order</span><span class="p">[</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">in_order_right</span><span class="p">):]</span>

    <span class="n">leftNode</span> <span class="o">=</span> <span class="n">reconstructTree</span><span class="p">(</span><span class="n">in_order_left</span><span class="p">,</span> <span class="n">pre_order_left</span><span class="p">)</span>
    <span class="n">rightNode</span> <span class="o">=</span> <span class="n">reconstructTree</span><span class="p">(</span><span class="n">in_order_right</span><span class="p">,</span> <span class="n">pre_order_right</span><span class="p">)</span>

    <span class="n">root</span><span class="p">.</span><span class="n">addLeft</span><span class="p">(</span><span class="n">leftNode</span><span class="p">)</span>
    <span class="n">root</span><span class="p">.</span><span class="n">addRight</span><span class="p">(</span><span class="n">rightNode</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">root</span>

</code></pre></div></div>

<h3 id="5-be-careful-about-details">5. Be careful about details</h3>
<p>Once the code is written, check it twice. Pay attention to boundary cases.</p>
<ul>
  <li>0-indexed vs 1-indexed?</li>
  <li>Double check the code where you add or substruct 1(if you do). Make sure that these boundaries are correct.</li>
  <li>Do you compare values anywhere? Check them - should a value be <em>greater</em> or <em>greater or equal</em>?</li>
  <li>Do you handle incorrect input?</li>
</ul>

<p>These were my learnings from this year Hackercup. If you ask me how far did I go, I tell you that I almost did it to round 3(not bad for the first try). Solve challenges and have fun! Good luck!</p>
